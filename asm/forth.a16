; =============================================
; Deep16 Forth Kernel
; Memory starts at 0x0100 as per spec
; =============================================

.org 0x0100
.code

; Register Usage:
; R0: Temporary (LDI target), AND mask holder
; R1: Temporary for operations
; R2: Temporary for operations  
; R3: Temporary for operations
; R4: AND mask (0x00FF)
; R5: Unused
; R6: Unused
; R7: Screen position counter
; R8/R9: Screen pointer pair for ES access
; R10: NEXT jump target
; R11: Instruction Pointer (IP)
; R12: Return Stack Pointer (RSP)
; R13: Stack Pointer (SP)
; R14: Link Register (LR)
; R15: Program Counter (PC)

; Forth Memory Layout:
; 0x0100-0x01FF: Forth kernel
; 0x0200-0x02FF: User dictionary
; 0x0300-0x7FFF: Data stack, return stack, heap

; =============================================
; Forth Kernel Implementation
; =============================================

forth_start:
    ; Initialize stack pointers
    LDI 0x7FF0
    MOV R13, R0        ; Data stack grows down from 0x7FF0 (R13)
    LDI 0x7FE0  
    MOV R12, R0        ; Return stack grows down from 0x7FE0 (R12)
    
    ; Initialize instruction pointer to user program (R11)
    LDI user_program
    MOV R11, R0
    
    ; Set up screen segment for output using R8/R9 pair
    LDI 0x0FFF
    INV R0             ; R0 = 0xF000
    MVS ES, R0         ; ES = 0xF000
    LDI 0x1000         ; Screen buffer starts at 0xF1000
    MOV R8, R0         ; Use R8 as screen pointer (R8/R9 pair)
    ERD R8             ; Use R8/R9 for ES access (PSW.ER=1000, DE=1)
    
    ; Clear screen position counter
    LDI 0
    MOV R7, R0         ; Use R7 as screen position counter
    
    ; Set up AND mask for byte operations
    LDI 0x00FF
    MOV R4, R0         ; R4 = 0x00FF for byte masking
    
    ; Set up NEXT jump target
    LDI next
    MOV R10, R0        ; R10 = address of next
    
    ; Jump to inner interpreter
    MOV PC, R10        ; Jump to next
    NOP

; =============================================
; Forth Inner Interpreter
; =============================================

next:
    ; Fetch next word from instruction stream
    LD R1, R11, 0      ; R1 = [R11] - get codeword (which is the code address)
    ADD R11, 1         ; R11++ - advance instruction pointer
    
    ; Jump to codeword directly (R1 already contains the code address)
    MOV PC, R1         ; Execute the word
    NOP

; =============================================
; Stack Primitives
; =============================================

; EXIT - return from word
d_exit:
    LD R11, R12, 0     ; Pop R11 from return stack
    ADD R12, 1         ; Adjust return stack
    MOV PC, R10        ; Jump back to next
    NOP

; LIT - push literal
d_lit:
    LD R1, R11, 0      ; Get literal value
    ADD R11, 1         ; Advance R11
    SUB R13, 1         ; Pre-decrement stack pointer
    ST R1, R13, 0      ; Push to stack
    MOV PC, R10        ; Jump back to next
    NOP

; DUP - duplicate top of stack
d_dup:
    LD R1, R13, 0      ; Get top of stack
    SUB R13, 1         ; Pre-decrement
    ST R1, R13, 0      ; Push duplicate
    MOV PC, R10        ; Jump back to next
    NOP

; DROP - drop top of stack  
d_drop:
    ADD R13, 1         ; Simply increment stack pointer
    MOV PC, R10        ; Jump back to next
    NOP

; SWAP - swap top two stack items
d_swap:
    LD R1, R13, 0      ; R1 = top (offset 0)
    LD R2, R13, 1      ; R2 = second (offset 1)
    ST R1, R13, 1      ; Swap positions
    ST R2, R13, 0
    MOV PC, R10        ; Jump back to next
    NOP

; =============================================
; Memory Operations
; =============================================

; @ (fetch) - ( addr -- value )
d_fetch:
    LD R1, R13, 0      ; Get address from stack
    LD R1, R1, 0       ; Fetch value from memory (offset 0)
    ST R1, R13, 0      ; Replace TOS with value
    MOV PC, R10        ; Jump back to next
    NOP

; ! (store) - ( value addr -- )
d_store:
    LD R1, R13, 0      ; Address (TOS)
    LD R2, R13, 1      ; Value (second)
    ST R2, R1, 0       ; Store value at address (offset 0)
    ADD R13, 2         ; Drop both items
    MOV PC, R10        ; Jump back to next
    NOP

; =============================================
; I/O Operations
; =============================================

; EMIT - output character
d_emit:
    LD R1, R13, 0      ; Get character from stack
    ADD R13, 1         ; Drop it
    
    STS R1, ES, R8     ; [ES:R8] = character
    ADD R8, 1          ; Advance screen pointer
    ADD R7, 1          ; Advance position counter
    
    ; Simple bounds checking - reset if at end of screen
    LDI 2000
    MOV R2, R0
    SUB R2, R7         ; 2000 - current_position
    JNZ emit_done      ; If not zero, continue
    NOP
    LDI 0x1000         ; Reset screen pointer
    MOV R8, R0
    LDI 0              ; Reset position counter
    MOV R7, R0
    
emit_done:
    MOV PC, R10        ; Jump back to next
    NOP

; TELL - output null-terminated string (one char per word)
d_tell:
    LD R3, R13, 0      ; R3 = string address
    ADD R13, 1         ; Drop address
    
tell_loop:
    LD R1, R3, 0       ; Get character from string
    ADD R1, 0          ; Set flags
    JZ tell_done       ; If zero, end of string
    NOP
    
    ; Output the character
    STS R1, ES, R8     ; [ES:R8] = character
    ADD R8, 1          ; Advance screen
    ADD R7, 1          ; Advance position
    
    ; Simple bounds checking
    LDI 2000
    MOV R2, R0
    SUB R2, R7         ; 2000 - current_position
    JNZ tell_next_char ; If not zero, continue
    NOP
    LDI 0x1000         ; Reset screen pointer
    MOV R8, R0
    LDI 0              ; Reset position counter
    MOV R7, R0
    
tell_next_char:
    ADD R3, 1          ; Next character address
    JNO tell_loop      ; Continue loop
    NOP
    
tell_done:
    MOV PC, R10        ; Jump back to next
    NOP

; CR - carriage return (move to next line)
d_cr:
    ; Calculate current column: position % 80
    MOV R1, R7         ; Copy position
    LDI 80
    MOV R2, R0
cr_mod_loop:
    SUB R1, R2         ; Subtract 80
    JN cr_done_mod     ; If negative, done
    NOP
    JNO cr_mod_loop
    NOP
cr_done_mod:
    ADD R1, R2         ; Add back the last 80
    ; Now R1 = current column
    
    ; Calculate spaces to next line: 80 - current_column
    LDI 80
    SUB R0, R1         ; 80 - current_column
    MOV R2, R0         ; R2 = spaces needed
    
    ; Add spaces to advance to next line
    LDI 0x20           ; Space character
    MOV R3, R0
cr_space_loop:
    ADD R2, 0          ; Set flags
    JZ cr_done         ; If no more spaces needed
    NOP
    STS R3, ES, R8     ; Output space
    ADD R8, 1          ; Advance screen
    ADD R7, 1          ; Advance position
    SUB R2, 1          ; Decrement counter
    JNO cr_space_loop
    NOP
    
cr_done:
    MOV PC, R10        ; Jump back to next
    NOP

; =============================================
; Demo Program - "Hello DeepForth!"
; =============================================
user_program:
    .word d_lit
    .word hello_str
    .word d_tell
    .word d_cr
    .word d_lit
    .word welcome_str
    .word d_tell
    .word d_cr
    .word d_exit

; =============================================
; String data - ONE CHARACTER PER WORD
; =============================================
hello_str:
    .word 'H'
    .word 'e'
    .word 'l'
    .word 'l'
    .word 'o'
    .word ' '
    .word 'D'
    .word 'e'
    .word 'e'
    .word 'p'
    .word 'F'
    .word 'o'
    .word 'r'
    .word 't'
    .word 'h'
    .word '!'
    .word 0

welcome_str:
    .word 'W'
    .word 'e'
    .word 'l'
    .word 'c'
    .word 'o'
    .word 'm'
    .word 'e'
    .word ' '
    .word 't'
    .word 'o'
    .word ' '
    .word 'D'
    .word 'e'
    .word 'e'
    .word 'p'
    .word '1'
    .word '6'
    .word ' '
    .word 'F'
    .word 'o'
    .word 'r'
    .word 't'
    .word 'h'
    .word '!'
    .word 0

; =============================================
; Dictionary Headers - Word Oriented Format
; =============================================

; Dictionary format: [link][name_length][name_chars... padded to word][code]
; Each name character occupies 16 bits (word-oriented)

dict_start:

; EXIT
.word 0                ; Link field (end of chain)
.word 0x4004           ; Length=4, then "EXIT" in 4 words
.word 0x4558           ; 'E' 'X'
.word 0x4954           ; 'I' 'T'
.word 0x0000           ; Padding
.word d_exit           ; Code field

; LIT  
.word dict_start       ; Link to previous
.word 0x4003           ; Length=3, then "LIT" in 3 words  
.word 0x4C49           ; 'L' 'I'
.word 0x5400           ; 'T' + padding
.word d_lit            ; Code field

; DUP
.word dict_start+12    ; Link to previous
.word 0x4003           ; Length=3, then "DUP" in 3 words
.word 0x4455           ; 'D' 'U'  
.word 0x5000           ; 'P' + padding
.word d_dup            ; Code field

; DROP
.word dict_start+24    ; Link to previous
.word 0x4004           ; Length=4, then "DROP" in 4 words
.word 0x4452           ; 'D' 'R'
.word 0x4F50           ; 'O' 'P'
.word 0x0000           ; Padding
.word d_drop           ; Code field

; SWAP
.word dict_start+36    ; Link to previous
.word 0x4004           ; Length=4, then "SWAP" in 4 words
.word 0x5357           ; 'S' 'W'
.word 0x4150           ; 'A' 'P'
.word 0x0000           ; Padding
.word d_swap           ; Code field

; EMIT
.word dict_start+48    ; Link to previous
.word 0x4004           ; Length=4, then "EMIT" in 4 words
.word 0x454D           ; 'E' 'M'
.word 0x4954           ; 'I' 'T'
.word 0x0000           ; Padding
.word d_emit           ; Code field

; TELL
.word dict_start+60    ; Link to previous
.word 0x4004           ; Length=4, then "TELL" in 4 words
.word 0x5445           ; 'T' 'E'
.word 0x4C4C           ; 'L' 'L'
.word 0x0000           ; Padding
.word d_tell           ; Code field

; CR
.word dict_start+72    ; Link to previous
.word 0x4002           ; Length=2, then "CR" in 2 words
.word 0x4352           ; 'C' 'R'
.word d_cr             ; Code field

; =============================================
; End of Kernel
; =============================================

kernel_end:
    HLT