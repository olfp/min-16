; =============================================
; Deep16 Forth Kernel
; Memory starts at 0x0100 as per spec
; =============================================

.org 0x0100
.code

; Register Usage:
; R11: Instruction Pointer (IP)
; R12: Return Stack Pointer (RSP)  
; R13: Stack Pointer (SP)
; R14: Link Register (LR) - used for temporary jumps
; R15: Program Counter (PC)

; Forth Memory Layout:
; 0x0100-0x01FF: Forth kernel
; 0x0200-0x02FF: User dictionary
; 0x0300-0x7FFF: Data stack, return stack, heap

forth_start:
    ; Initialize stack pointers
    LDI 0x7FF0
    MOV R13, R0        ; Data stack grows down from 0x7FF0 (R13)
    LDI 0x7FE0  
    MOV R12, R0       ; Return stack grows down from 0x7FE0 (R12)
    
    ; Initialize instruction pointer to user program (R11)
    LDI user_program
    MOV R11, R0
    
    ; Set up screen segment for output
    LDI 0x0FFF
    INV R0            ; R0 = 0xF000
    MVS ES, R0        ; ES = 0xF000
    LDI 0x1000        ; Screen buffer starts at 0xF1000
    MOV R10, R0       ; Use R10 as screen pointer
    ERD R10           ; Use R10/R11 for ES access
    
    ; Clear screen position counter (R9)
    LDI 0
    MOV R9, R0
    
    ; Jump to inner interpreter
    JMP next
    NOP

; =============================================
; Forth Inner Interpreter
; =============================================

next:
    ; Fetch next word from instruction stream
    LD R1, R11, 0      ; R1 = [R11] - get codeword address
    ADD R11, R11, 1     ; R11++ - advance instruction pointer
    
    ; Jump to codeword
    LD R2, R1, 0      ; R2 = [R1] - get actual code address
    JMP R2            ; Execute the word
    NOP

; =============================================
; Forth Primitive Words
; =============================================

; EXIT - return from word
d_exit:
    LD R11, R12, 0     ; Pop R11 from return stack
    ADD R12, R12, 1   ; Adjust return stack
    JMP next
    NOP

; LIT - push literal
d_lit:
    LD R1, R11, 0      ; Get literal value
    ADD R11, R11, 1     ; Advance R11
    ST R1, R13, -1     ; Push to data stack
    ADD R13, R13, -1    ; Adjust stack
    JMP next
    NOP

; DUP - duplicate top of stack
d_dup:
    LD R1, R13, 1      ; Get top of stack
    ST R1, R13, -1     ; Push duplicate
    ADD R13, R13, -1    ; Adjust stack
    JMP next
    NOP

; DROP - drop top of stack
d_drop:
    ADD R13, R13, 1     ; Adjust stack
    JMP next
    NOP

; SWAP - swap top two stack items
d_swap:
    LD R1, R13, 1      ; R1 = top
    LD R2, R13, 2      ; R2 = second
    ST R1, R13, 2      ; Swap them
    ST R2, R13, 1
    JMP next
    NOP

; EMIT - output character
d_emit:
    LD R1, R13, 1      ; Get character from stack
    ADD R13, R13, 1     ; Drop it
    
    ; Store character to screen
    STS R1, ES, R10   ; [ES:R10] = character
    
    ; Advance screen position
    ADD R10, R10, 1
    ADD R9, R9, 1
    
    JMP next
    NOP

; TELL - output string (addr -- )
d_tell:
    LD R3, R13, 1      ; R3 = string address
    ADD R13, R13, 1     ; Drop address
    
tell_loop:
    LD R1, R3, 0       ; Get character from string
    JZ R1, tell_done   ; If zero, end of string
    NOP
    
    ; Push character and call EMIT
    ST R1, R13, -1     ; Push character for EMIT
    ADD R13, R13, -1
    
    ; Save current state
    ST R11, R12, -1    ; Push R11 to return stack
    ST R3, R12, -2     ; Push string pointer
    ADD R12, R12, -2
    
    ; Call EMIT
    LDI d_emit
    MOV R4, R0
    LD R4, R4, 0       ; Get EMIT code address
    JMP R4             ; Call EMIT
    NOP
    
    ; Restore state
    LD R3, R12, 0      ; Pop string pointer
    LD R11, R12, 1     ; Pop R11
    ADD R12, R12, 2
    
    ADD R3, R3, 1      ; Next character
    JMP tell_loop
    NOP
    
tell_done:
    JMP next
    NOP

; =============================================
; Demo Program - "Hello DeepForth!"
; =============================================

user_program:
    .word d_lit       ; LIT
    .word hello_str   ; Address of string
    .word d_tell      ; TELL (output string)
    .word d_exit      ; EXIT

; String data using .text directive (auto-null-terminated)
hello_str:
    .text "Hello DeepForth!"

; =============================================
; Dictionary Headers
; =============================================

; Dictionary format: [link][name][code]
dict_start:

; EXIT
.word 0              ; NULL link (end of dictionary)
.word 0x4558         ; "EX" name (2 chars)
.word 0x4954         ; "IT" name continued  
.word d_exit         ; Code word

; LIT  
.word dict_start     ; Link to previous
.word 0x4C49         ; "LI"
.word 0x5400         ; "T" + padding
.word d_lit

; DUP
.word dict_start+6   ; Link to LIT
.word 0x4455         ; "DU" 
.word 0x5000         ; "P" + padding
.word d_dup

; DROP
.word dict_start+12  ; Link to DUP
.word 0x4452         ; "DR"
.word 0x4F50         ; "OP"
.word d_drop

; SWAP
.word dict_start+18  ; Link to DROP  
.word 0x5357         ; "SW"
.word 0x4150         ; "AP"
.word d_swap

; EMIT
.word dict_start+24  ; Link to SWAP
.word 0x454D         ; "EM"
.word 0x4954         ; "IT"
.word d_emit

; TELL
.word dict_start+30  ; Link to EMIT
.word 0x5445         ; "TE"
.word 0x4C4C         ; "LL"
.word d_tell

; =============================================
; End of Kernel
; =============================================

kernel_end:
    HLT
